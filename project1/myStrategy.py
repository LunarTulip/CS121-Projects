def myStrategy(myscore, theirscore, last): #The best strategy I could come up with. Beats all test strategies given large n, plus beats my other strategies-able-to-beat-all-test-strategies-given-large-n given large n.
    leeway = 100 - myscore #Establishes how many points I can gain without losing. Useful in further calculations.
    if last: #If the opponent rolled 0 the previous turn, figures out optimal response. As far as I can tell, my setup here places me at the theoretical maximum possible win:loss ratio; I can't see any areas in which it gets less than the maximum possible win% for a given set of scores.
        if theirscore > myscore: #If their score is higher than mine, calculates the midpoint between their score and 100, then rolls the number of dice whose expected value is closest to that midpoint.
            theirlead = theirscore - myscore #Establishes gap between their score and mine.
            errormargin = leeway - theirlead #Establishes gap between their score and 100. Uses a slightly roundabout method to do so, but since leeway is 100 - myscore and theirlead is theirscore - myscore, the myscores cancel and the result becomes the same as 100 - theirscore.
            target = theirlead + (0.5 * errormargin) #Determines how many points I'd have to gain to be at the exact midpoint between their score and 100.
            return max(round(target / 2.5), 1) #Rolls the number of dice whose expected value (2.5 times the number rolled) will place me closest to the previously-calculated midpoint. If the midpoint less than 1.25 above my score, rolls 1 anyway, because rolling 0 has no chance of moving my score above theirs.
        elif theirscore == myscore: #If their score is equal to mine, rolls the number of dice which returns, to a first approximation, the highest ratio of wins to losses.
            saferoll = int(leeway * 0.2) #This is how many dice I can roll with absolutely no chance of going over 100.
            if myscore > 97: #If my score is above 97, any roll will have a higher chance of putting me over 100 than of putting me over my current score but not-over-100, and it's thus not worth rolling at all.
                return 0 #Rolls 0 dice for the reason described in the line above.
            elif myscore % 5 == 2 and saferoll < 4: #If my score is two above the minimum at which a given roll is safe, and I'm not rolling many dice, the probabilities add up such that the increased chance of going over 100 if I roll one die more than is safe is less than the lowered chance of rolling 0 and getting a draw, and it's thus worth adding the extra die. Starting at a roll of 4, the probabilities turn around; at 4 they change by exactly-equal amounts, and at 5 and onward the loss chance increases by more than the win chance decreases.
                return saferoll + 1 #Rolls the safe number plus one for the reason described in the line above.
            elif myscore % 5 == 1: #If my score is one above the minimum at which a given roll is safe, similar considerations apply to if it's two above, except the ratio never drops into unfavorability, at least within the bounds of the game, so there's no need to limit the saferoll values like I did when it was two above.
                return saferoll + 1 #Rolls the safe number plus one for the reason described in the line above.
            else: #If my score is neither one nor two above the minimum at which a given roll is safe, then the added risk of extra dice beyond the safe number is always equal to or greater than the added reward, so I just roll the safe number.
                return saferoll #Rolls the safe number for the reason described in the line above.
        else: #If their score is neither greater than nor equal to mine, it's below mine, so I don't need to roll anything; I'm already there.
            return 0 #Rolls 0, because there's no point in wasting processing time figuring out if other rolls are safe or not when there's no benefit to doing so.
    elif myscore == 0: #If my score is 0, I roll 33 dice, because I found through extensive testing of different possible numbers (25-35) that 33 was the spot which got me the most wins.
        return 33 #Rolls 33 for the reason described in the line above.
    elif myscore == 97 and theirscore == 97: #Ordinarily, rolling 0 given a score of 97 helps more than it hurts; however, if their score is also 97, and they're using a reasonably strong last-move strategy like mine above, they'll win more if I roll 0 than they will if I roll 1. Thus, this specific condition is an exception to the usual rolling-0-at-97-points-is-good rule. I specifically roll 1 because it's much less likely than rolling 2 would be to put me over 100 points.
        return 1 #Rolls 1 for the reason described in the line above.
    elif leeway > 3 or theirscore > myscore: #If my score is below 97, it's too easy for the opponent to catch up to me in their single remaining turn should I roll 0 (at least given a competent opponent whose score is also reasonably high), so it's in my interest to increase it further. If their score is above mine, rolling 0 guarantees me a loss, so it's similarly in my interest to increase my score. The specific number of .29 times my leeway arose from testing; I tested all numbers from .25 to .35, and .29 came out on top.
        return max(int(leeway * 0.29), 1) #Rolls .29 times my leeway (rounded down) for the reason described in the line above. If the rounding-down would lead to rolling 0, rolls 1 anyway, because I don't want to pass if I'm running this line.
    else: #If my score is 97 or above and the opponent's isn't, or my score is 98 or above and the opponent isn't above me, and it's not the last turn, rolling further would be counterproductive. The point at which rolling further is counterproductive is the point at which it becomes optimal to pass, so that's exactly what I do.
        return 0 #Rolls 0 for the reason described in the line above.